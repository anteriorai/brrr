from __future__ import annotations

from dataclasses import dataclass


@dataclass
class Call:
    """A full brrr request payload.

    This is a low-level brrr primitive.

    The memo key must be generated by the instantiator of this class, and it
    must be deterministic: the "same" args and kwargs must always encode to the
    same memo key.

    Using the same memo key, we store the task and its argv here so we can
    retrieve them in workers.

    <docsync>Call</docsync>
    """

    # Ideally human readable name for this task.  Brrr treats this as an opaque
    # string and doesn’t do any kind of splitting on /, or versioning, etc, on
    # this at all: BYO versioning scheme.  I strongly recommend simple
    # ascii-encodable strings, maybe some unicode, but definitely avoid
    # non-printable characters.
    #
    # Compare this to the path of a HTTP request.
    task_name: str

    # Payloads at this level of brrr are always just plain byte strings.
    # Example: JSON encoded serialization of the arguments, so e.g. for
    # ‘some_func(a=1, b="foo")’, the payload could be ‘{"a": 1, "b": "foo"}’.
    # Or it could be ‘[1, "foo"]’.  Or it could be a pickled version instead.
    # Or it could be anything you want: brrr doesn’t inspect this value ever.
    # This is treated as an opaque string.  It doesn’t even have to be
    # consistent for repeated calls which represent the same semantics: that’s
    # what the separate “call hash” is for.
    #
    # If you want to work cross language of course this part has to be
    # serializable / deserializable cross language.
    #
    # Compare this to the body and/or the query string of a HTTP request.
    payload: bytes

    # A unique, deterministic identifier for this task invocation.
    #
    # The reference implementation is using sha256 on a the name, a naive
    # serialization of the args, and on the sorted dictionary with a naive
    # serialization of its values.  For correct operation of Brrr, this property
    # must be deterministic and consistent for the “same” Call--whatever that
    # means for your implementation.  Your best bet is to be strict here and
    # define an explicit hash which don't rely on possibly non-deterministic
    # serialization of data structures (e.g. str(dict) could be dependent on
    # insertion order, or python version, etc).
    #
    # Pay close attention to this field when you work cross language: while it
    # makes little sense for different languages to support serving the same
    # calls, they must all correctly and deterministically and identically hash
    # the same invocation to the same output hash.  So if you want to call, say,
    # a task served by Go, from a worker (or other code) in Python, they must
    # both agree on what the input arguments to that call would look like for
    # the environment, and derive the same hash from it.
    #
    # The value MUST be a string with only characters in the printable US-ASCII
    # range.  Obvious candidates are base64 and hexadecimal.
    #
    # N.B.: This is the ONLY value used for comparing identity of calls, so
    # include the task_name in here.
    #
    # HTTP requests don’t have a good analog for this.
    call_hash: str

    def __eq__(self, other: object) -> bool:
        # Note the absence of checking the payload here.  That’s the point of
        # the call_hash.  Even the absence of the task_name!  Again the point.
        return isinstance(other, Call) and self.call_hash == other.call_hash

    def __str__(self) -> str:
        return f"Call({self.task_name}, {self.call_hash[:6]}...)"

    def __repr__(self) -> str:
        return f"<Call({self.task_name!r}, {self.call_hash!r})>"
