from dataclasses import dataclass


@dataclass
class Call:
    """A metadata object for Deferrals to communicate with the outer loop.

    The memo key must be generated by the instantiator of this class, and it
    must be deterministic: the "same" args and kwargs must always encode to the
    same memo key.

    Using the same memo key, we store the task and its argv here so we can
    retrieve them in workers.

    """

    task_name: str
    # A unique, deterministic identifier for this task invocation.
    #
    # The reference implementation is using sha256 on a the name, a naive
    # serialization of the args, and on the sorted dictionary with a naive
    # serialization of its values.  For correct operation of Brrr, this property
    # must be deterministic and consistent for the “same” Call--whatever that
    # means for your implementation.  Your best bet is to be strict here and
    # define an explicit hash which don't rely on possibly non-deterministic
    # serialization of data structures (e.g. str(dict) could be dependent on
    # insertion order, or python version, etc).
    #
    # Pay close attention to this field when you work cross language: while it
    # makes little sense for different languages to support serving the same
    # calls, they must all correctly and deterministically and identically hash
    # the same invocation to the same output hash.  So if you want to call, say,
    # a task served by Go, from a worker (or other code) in Python, they must
    # both agree on what the input arguments to that call would look like for
    # the environment, and derive the same hash from it.
    memo_key: str

    def __eq__(self, other):
        return isinstance(other, Call) and self.memo_key == other.memo_key

    def __str__(self):
        return f"Call({self.task_name})"
